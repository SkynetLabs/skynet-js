import { deriveChildSeed, encodeBigintAsUint64, genKeyPairFromSeed, hashRegistryEntry } from "./crypto";
import { maxint, toHexString } from "./utils";

declare global {
  // eslint-disable-next-line @typescript-eslint/no-namespace
  namespace jest {
    interface Matchers<R> {
      toEqualUint8Array(argument: Uint8Array): R;
    }
  }
}

expect.extend({
  // source https://stackoverflow.com/a/60818105/6085242
  toEqualUint8Array(received: Uint8Array, argument: Uint8Array) {
    if (received.length !== argument.length) {
      return { pass: false, message: () => `expected ${received} to equal ${argument}` };
    }
    for (let i = 0; i < received.length; i++) {
      if (received[i] !== argument[i]) {
        return { pass: false, message: () => `expected ${received} to equal ${argument}` };
      }
    }
    return { pass: true, message: () => `expected ${received} not to equal ${argument}` };
  },
});

describe("areEqualUint8Arrays", () => {
  it("should correctly check whether uint8arrays are equal", () => {
    expect(new Uint8Array([0])).toEqualUint8Array(new Uint8Array([0]));
    expect(new Uint8Array([1, 1, 0])).toEqualUint8Array(new Uint8Array([1, 1, 0]));
    expect(new Uint8Array([1, 0, 0])).not.toEqualUint8Array(new Uint8Array([1, 1, 0]));
    expect(new Uint8Array([1, 1, 0])).not.toEqualUint8Array(new Uint8Array([1, 1, 0, 0]));
  });
});

describe("deriveChildSeed", () => {
  it("should correctly derive a child seed", () => {
    // Hard-code expected values to catch any breaking changes.

    const masterSeed = "c1197e1275fbf570d21dde01a00af83ed4a743d1884e4a09cebce0dd21ae254c";
    const seed = "seed";
    const expected = "6140d0d1d8f9e2b759ca7fc96ad3620cd382189f8d46339737e26a2764122b99";

    const childSeed = deriveChildSeed(masterSeed, seed);
    expect(childSeed).toEqual(expected);

    const seed1 = deriveChildSeed(masterSeed, "asd");
    const seed2 = deriveChildSeed(masterSeed, "aa");
    const seed3 = deriveChildSeed(masterSeed, "ds");
    expect(seed1).not.toEqual(seed2);
    expect(seed2).not.toEqual(seed3);
  });
});

describe("encodeBigint", () => {
  it("should correctly encode bigints", () => {
    expect(encodeBigintAsUint64(BigInt(0))).toEqualUint8Array(new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0]));
    expect(encodeBigintAsUint64(BigInt(255))).toEqualUint8Array(new Uint8Array([255, 0, 0, 0, 0, 0, 0, 0]));
    expect(encodeBigintAsUint64(BigInt(256))).toEqualUint8Array(new Uint8Array([0, 1, 0, 0, 0, 0, 0, 0]));
    expect(encodeBigintAsUint64(BigInt(256))).not.toEqualUint8Array(new Uint8Array([1, 1, 0, 0, 0, 0, 0, 0]));
    expect(encodeBigintAsUint64(BigInt(maxint))).toEqualUint8Array(
      new Uint8Array([255, 255, 255, 255, 255, 255, 255, 255])
    );
    expect(() => encodeBigintAsUint64(BigInt(maxint) + BigInt(1))).toThrowError(
      "Argument 18446744073709551616 does not fit in a 64-bit unsigned integer; exceeds 2^64-1"
    );
  });
});

describe("genKeyPairFromSeed", () => {
  it("should create an expected keypair from a given seed", () => {
    // Hard-code expected values to catch any breaking changes.
    const seed = "c1197e1275fbf570d21dde01a00af83ed4a743d1884e4a09cebce0dd21ae254c";
    const expectedPublicKey = "f8a7da8324fabb9d57bb32c59c48d4ba304d08ee5f1297a46836cf841da71c80";
    const expectedPrivateKey =
      "c404ff07fba961000dfb25ece7477f45b109b50a5169a45f3fb239343002c1cff8a7da8324fabb9d57bb32c59c48d4ba304d08ee5f1297a46836cf841da71c80";

    const { publicKey, privateKey } = genKeyPairFromSeed(seed);
    expect(publicKey).toEqual(expectedPublicKey);
    expect(privateKey).toEqual(expectedPrivateKey);
  });
});

describe("hashRegistryValue", () => {
  it("should match siad for equal input", () => {
    // Hard-code expected values to catch any breaking changes.

    // "h" is the hash generated by siad with the same input parameters
    const h = "788dddf5232807611557a3dc0fa5f34012c2650526ba91d55411a2b04ba56164";
    const hash = hashRegistryEntry({
      datakey: "HelloWorld",
      data: "abc",
      revision: BigInt(123456789),
    });

    expect(toHexString(hash)).toEqual(h);
  });
});
